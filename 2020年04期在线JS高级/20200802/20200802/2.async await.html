<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>珠峰Web高级课</title>
</head>

<body>
    <script>
        /*
         * async / await 是ES7中提供的，它是对promise的一个补充（promise语法糖）
         *   用async修饰一个函数，函数返回的结果都会变为一个promise实例
         *      + 状态：大多都是成功的，如果代码执行报错，返回失败，再如果手动返回一个新的promise实例，则按照新实例的状态处理
         *   
         *   用await可以把一个异步任务变为类似于同步的效果（本质不是同步，还是异步，而且是异步中的微任务）
         */
        /* async function fn() {
            console.log(a);
            return 10;
        }
        console.log(fn()); */
/* 
        function fn1() {
            return 10;
        }

        function fn2() {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve(2);
                }, 2000);
            });
        }

        function fn3() {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    reject(3);
                }, 1000);
            });
        } */

        // (async function () {
        //     // 方法中想用await，必须把方法基于async修饰
        //     //  + 先把fn2执行，观察fn2返回的是成功还是失败的promise
        //     //  + 异步性：它会把当前上下文，await下面的代码整体都当作一个异步的微任务，放置在EventQueue中
        //     //  + await只是处理promise实例是成功状态的，如果返回转态是成功，则value拿到的是[[PromiseValue]]，并且把之前存储的异步任务拿到栈中让主线程把其执行
        //     // await处理后，立即把函数执行，哪怕函数立即返回成功或者失败的状态，await也没有把其立即处理，而是先等同步的都执行完，再去执行这些异步的任务
        //     try {
        //         // 对于await处理的时候，如果返回的是失败的promise，则await下面代码不再执行，失败情况下没有处理，浏览器抛出一个异常信息，此时我们可以基于try/catch捕获到异常，从而进行异常的处理
        //         let value = await fn3();
        //         console.log(value);
        //         console.log('@@');
        //     } catch (e) {}
        // })();
        // console.log(1);
    </script>

    <script src="3.promiseA+.js"></script>
</body>

</html>