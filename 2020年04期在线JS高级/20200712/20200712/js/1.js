var x = [12, 23];
function fn(y) {
	y[0] = 100;
	y = [100];
	y[1] = 200;
	console.log(y);
}
fn(x);
// fn(x);
console.log(x);

/*
 * 创建一个函数
 *    1.开辟一个堆内存（16进制的内存地址：AAAFFF111）
 *    2.声明当前函数的作用域（在哪个上下文中创建的，它的作用域就是谁）
 *    3.把函数体中的代码当做“字符串”存储在堆内存中（创建一个函数，存储的是一堆字符串，所以函数只要不执行，函数其实没啥意义）
 *    4.把函数堆的地址类似于对象一样，放置在栈中供变量调用(函数名)
 * 
 * 执行函数
 *    1.会形成一个全新的私有上下文 EC(xx)（目的是供函数体中的代码执行），然后进栈执行
 *    2.在私有上下文中有一个存放私有变量的变量对象 AO(xx)
 *    3.在代码执行之前要做的事情很多：
 *      初始化它的作用域链 <自己上的上下文,函数的作用域>
 *      初始化THIS （箭头函数没有THIS）
 *      初始化ARGUMENTS实参集合（箭头函数没有ARGUMENTS）
 *      形参赋值（形参变量是函数的私有变量，需要存储在AO中的）
 *      变量提升（在私有上下文中声明的变量都是私有变量）
 *      ......
 *    4.代码执行（把之前在函数堆中存储的字符串，拿过来在上下文中依次执行）
 *      作用域链查找机制：在代码执行中，遇到一个变量，我们首先看一下是否为自己的私有变量，如果是自己的私有变量，接下来所有操作都是操作私有的（和外界没有直接的联系）；如果不是自己私有的，则按照scope-chain，向上级上下文中查找（如果是上级私有的，接下来的操作都是操作上级上下文中的变量）....一直找，直到找到EC(G)为止
 *      
 *    5.根据实际的情况确定当前上下文是否出栈释放
 *      为了保证栈内存的大小（内存优化），一般情况下，如果当前函数执行产生的上下文，在进栈且代码执行完成后，会把次上下文移除栈（上下文释放到了：之前在上下文中存储的私有的变量等信息也就有跟着释放了） =>全局上下文是在打开页面生成的，也需要在关闭页面的时候释放掉(只有页面关闭才会被释放掉) 
 *       特殊情况：只要当前上下文中的某些内容，被上下文以外的东西占用，那么当前上下文是不能被释放的（上下文中存储的变量等信息也保留下来了） =>这种情况就是大家认为的闭包
 * 
 * 函数第二次执行，会形成一个全新的私有上下文，把之前做过的事情，还是原封不动的再执行一次（所有的东西都是从头来一遍的），此时形成的上下文和上一次形成的上下文之间没有必然的联系
 */

//  闭包：它是函数运行时候所产生的机制，函数执行会形成一个全新的私有上下文，可以保护里面的私有变量和外界互不干扰（保护机制），但是大家所认为的闭包，需要当前上下文不能被出栈释放，这样私有变量及它的值也不会被释放掉（保存机制）；
//  闭包的作用：保护/保存

/*
 * JS中的内存优化
 *   【栈内存（执行上下文）】 
 *       一般情况下，函数执行完，所形成的上下文会被出栈释放掉
 *       特殊情况：当前上下文中某些内容被上下文以外的事物占用了，此时不能出栈释放
 *       全局上下文：加载页面创建的，也只是有页面关闭才会被释放掉
 *   【堆内存】
 *       浏览器的垃圾回收机制：
 *       1. 引用计数（以IE为主）：在某些情况下会导致计数混乱，这样会造成内存不能被释放（内存泄漏） =>回去后看JavaScript高级程序设计第三版最后的章节
 *       2. 检测引用(占用)（以谷歌为主）：浏览器在空闲时候会依次检测所有的堆内存，把没有被任何事物占用的内存释放掉，以此来优化内存
 * 
 *    手动释放内存，其实就是解除占用（手动赋值为null即可）
 * 
 * 闭包好不好？
 *    大量应用闭包肯定会导致内存的消耗，但是闭包保护和保存作用，在真实开发中我们还是需要的，所以需要学会 “合理使用闭包”
 * 
 * 闭包的应用：
 *    ECStack/EC/AO/VO/SCOPE/SCOPE-CHAIN/释放不释放/垃圾回收机制...
 *    1. 实战用途
 *    2. 高阶编程：柯理化/惰性函数/compose函数
 *    3. 源码分析：JQ/LODASH/REACT(REDUX/高阶组件/HOOKS)...
 *    4. 自己封装插件组件的时候
 *    ...
 */
