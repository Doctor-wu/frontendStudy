# 设计模式



## 设计原则

### 

### 什么是设计？

- 按哪一种思路或者标准来实现功能
- 功能相同，可以有不同设计的方式
- 需求如果不断变化，设计的作用才能体现出来



### SOLID五大设计原则

1. **S - 单一职责原则**

   单一功能原则认为对象应该仅具有一种单一功能的概念

2. **O - 开放封闭原则**

   开闭原则则认为“软件体应该是对于拓展开放，但是对于修改封闭的”的概念

3. **L - 里氏替换原则**

   里氏替换原则认为"程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的"的概念。参考 契约式设计

4. **I - 接口隔离原则**

   接口隔离原则认为"多个特定客户端接口要好于一个宽泛用途的接口"的概念

5. **D - 依赖倒置原则** 

   依赖倒置原则认为一个方法应该遵从"依赖于抽象而不是一个实例"的概念。依赖注入是该原则的一种实现方式

   

 

## 面向对象模式

- 把客观对象抽象成属性数据和对数据的相关操作，把内部细节和不相关的信息隐藏起来
- 把同一个类型的客观对象的属性数据和操作绑定在一起，封装成类
- 并且允许分成不同层次进行抽象，通过继承实现属性和操作的共享
  - 面向对象的分析OOA
  - 面向对象的设计OOD
  - 面向对象的编程OOP

### 

## 工厂模式



### 简单工厂模式

简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例

**直接new的缺点**

耦合，依赖具体实现



### 工厂方法模式

- 工厂方法模式Factory Method，又称多态性工厂模式
- 在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。

**这种情况会耦合工厂类，但是遵循开闭原则**



### 抽象工厂模式

- 抽象工厂模式是指当有多个抽象角色时， 使用的一种工厂模式
- 抽象工厂模式可以想客户端提供一个接口，是客户端在不必指定产品的具体的情况下，创建多个产品簇中的产品对象



## 单例模式

全局存在且仅存在一个实例

```js
/**
 * 普通单例
 *  缺点是类的使用者必须知道这是一个单例模式的类，并且主动调用获取实例的方法
 * */


/**
 * 透明单例模式
 *  类的使用者正常使用即可
 * */


/***
 * 创建单例函数的函数
 * @param Cstr
 * @constructor
 */

```



## 适配器模式

把不能直接关联的二者通过适配器交互

把数据适配成需要的结构

**例子**

参数适配，返回值的适配，把同步方法适配成Promise版





## 装饰器模式

- 在不改变其原有点结构和功能为对象添加新功能
- 装饰比继承更加灵活

**应用**

AOP





## 代理模式

- 由于一个对象不能直接引用另一个对象，所以需要通过代理对象在这两个对象之间起到中介作用
- 可以在使用者和目标对象之间加一个代理对象，通过代理可以实现控制 

**应用**

图片懒加载

事件代理 



## 观察者模式

- 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同事监听一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使他们能够自动更新



## 发布订阅模式

1. 订阅者把自己想订阅的事件注册到调度中心
2. 当该事件触发时，发布者发布盖事件到调度中心，由调度中心统一调度订阅者注册到调度中心的处理代码
3. 虽然两种模式都存在订阅者和发布者(观察者可认为是订阅者，被观察者可认为是发布者)
4. 但是观察者模式是由被观察者调度的，而发布/订阅模式是由调度中心统一调用的
5. 所以观察者模式的订阅者与发布者之间是存在依赖的，而发布/订阅模式则不会



## 外观模式

该模式就是把一些复杂的流程封装成一个接口供给外部用户更简单的使用

- 面面角色：外观模式的核心。它被客户角色调用，它熟悉子系统的功能。内部根据客户角色的需求预订功能组合。
- 子系统角色：实现了子系统的功能。它对客户角色和Facade是未知的
- 客户角色：通过调用Facade来完成要实现的功能

**场景**：redux





## 状态模式

- 当一个对象内部状态发生改变时，会导致其行为发生改变，这看起来像是改变了对象
- 对象有自己的状态
- 不同状态下执行的逻辑不一样
- 明确状态和每个状态下执行的动作
- 用来减少if...else 字句 



## 策略模式

- 将定义的一组算法封装起来，使其相互之间可以替换。封装的算法具有一定独立性，不会随客户端改变而改变
- 避免大量的if-else 或 switch-case语句 



## 原型模式

- 原型模式是一个创建型模式
- 创建基类的时候，简单差异化的属性放在构造函数中，资源消耗相同的功能放在基类原型中



## 桥接模式

- 将抽象部分与他的实现部分分离，这样抽象化与实现化解耦，使他们可以独立变化
- 应用场景是实现系统可能有多个角度分类，每一种角度都可能变化
- 桥方可以通过实现桥接口进行单方面扩展，而另一方可以继承抽象类而单方面扩展，而之间的调用就从桥接口来作为突破口，不会受到双方扩展的任何影响

函数中this的耦合，DOM操作的耦合可以用桥接模式来解决 

和适配器的区别

适配器是把原来不能作用在一起的封装和改造后可以使用了

桥接模式是不改变原来的功能，把多个东西组合在一起使他们能交互但是不改变被连接的抽象或实例



























