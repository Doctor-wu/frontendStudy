## 掌握变量提升的处理机制



- **声明过的变量是不会重复声明的,但是会覆盖赋值**

```javascript
// 全局上下文的变量提升
//   fn=>1
//     =>2
//   var fn; 已经声明过了
//     =>4
//     =>5
//   全局上下文有一个全局变量fn，值是输出5的函数

fn();// 5
function fn(){ // 变量提升阶段已经处理过了，这里不再处理
    console.log(1);
}
fn();// 5
function fn(){ // 变量提升阶段已经处理过了，这里不再处理
    console.log(2);
}
fn();// 5
var fn = function fn(){ // var fn不用再处理，但是赋值在变量提升阶段没处理过，此处需处理 全局上下文中的那个函数输出3
    console.log(3);
}
fn();// 3
function fn(){
    console.log(4);
}
fn();// 3
function fn(){
    console.log(5);
}
fn();// 3
```



## 类型转换

```javascript
console.log([]==false);
console.log(![]==false);











// 答案 true	true

// []==false
// 对象==布尔 	都转换成数字（隐式转换）
// [] -> "" -> 0
// false -> 0
// 0 == 0

// ![]==false
// ![]把数组转换成布尔类型再取反 -> false
// false == false

```

```javascript
typeof !parseInt(null) + !isNaN(null)




// 答案 booleantrue

// 加号优先级最低, 先执行typeof 然后 再执行后面的加号
```

```javascript
let result = 10 + false + undefined + [] + 'Tencent' + null + true + {};
console.log(result);
// 10 + false => 10
// 10 + undefined => NaN
// NaN + [] => "NaN"
// "NaN" + "Tencent" => "NaNTencent"
// "NaNTencent" + null => "NaNTencentnull"
// "NaNTencentnull" + true => "NaNTencentnulltrue"
// "NaNTencentnulltrue" + {} => "NaNTencentnulltrue[object Object]"
```

```javascript
let arr = [10.18, 0, 10, 25, 23];
arr = arr.map(parseInt);
console.log(arr);




// 答案 [10, NaN, 2, 2, 11]
// parseInt([value], radix) radix 是一个进制，不写或者写0都按照10进制处理（特殊情况，如果value以0x开头，则按16进制处理），radix应该在 2 ~ 36之间（0可以），如果不在这个区间，整个程序运行的结果都是NaN
// 从左到右依次查找符合radix的值（遇到一个不合法的即刻停止查找），再按照radix把值转换为十进制的
// parseInt('10.18', 0) // 10
// parseInt('0', 1) // NaN
// parseInt('10', 2) // 2
// parseInt('25', 3) // 2    2   5（不符合radix：3，舍弃）
// parseInt('23', 4) // 11
```

