## 闭包

### 什么是闭包

闭包是函数运行时所产生的机制，函数执行的时候会形成一个全新的私有上下文，可以保护当前函数的私有变量和外界互不干扰（**保护机制**），在这个上下文中，某些内容被当前上下文以外的东西占用，那么当前上下文在函数执行完毕是不能释放的（上下文存储的变量等信息也保留了下来 -> **保存机制**），这就形成了闭包

### 闭包的作用

- 保护机制

- 保存机制

### 闭包好不好 ？

不好。大量应用闭包肯定会导致内存的消耗，但是闭包的保护机制和保存机制在真实开发中还是需要的，所以需要**合理使用**闭包

### 闭包的应用

1. 实战用途
2. 高阶编程：柯里化/惰性函数/compose函数
3. 框架源码分析：JQ/LODASH/REACT
4. 自己封装插件组件的时候

### 面试回答：你对闭包是怎么理解的

ECStack/EC/AO/VO/SCOPE/SCOPE-CHAIN/释放与不释放/垃圾回收机制

实战应用

## 作用域

### 函数的作用域

函数在哪个上下文创建，作用域就是哪个上下文

### 块级作用域

在ES6中，基于let/const创建变量，如果是出现在**非函数和对象的大括号中**，大括号包裹的范围是一个**全新的块级作用域**

ES6之前不存在块级作用域，所以除函数的私有变量外，所有变量都是全局上下文中的变量

```javascript
for(let i = 0;i < 5; i++){
    console.log(i);
}

// 这个过程会产生6个块级作用域
// 除了5个循环产生的块级作用域还有一个父级作用域用来控制循环
```





## JS中的内存优化

### 【   栈内存 （执行上下文）】

一般情况下，函数执行完，所形成的执行上下文会被出栈释放掉

特殊情况：当前上下文中的某些内容被当前上下文以外的东西占用了，此时不能出栈释放

全局上下文：加载页面的时候创建的，只有页面关闭时才会释放

### 【   堆内存   】

#### 垃圾回收机制

1. 以IE为主的**引用计数**	存在一个问题：*在某些情况下会导致计数混乱，这样会造成内存泄漏*
2. 以Chrome为主的**检测引用**（或**标记清除**）=>浏览器在空闲时候依次检测所有堆内存，把没有被任何东西占用的内存释放掉，以此优化内存

手动释放内存其实就是接触占用（手动赋值为null即可）